#!/usr/bin/perl -w

use strict;
use open ':std', ':encoding(UTF-8)';
use utf8;
use Mojolicious::Lite;
use URI;
use DBI;
use JSON;
use Carp;
use FindBin qw($Bin);
use Encode;
use POSIX;
use Scalar::Util;
use Data::Dumper;
use Hash::Flatten qw/unflatten/;

my $dbdir="$Bin/databases";

# FiDB Middleware - Translate API Calls from network to database
# On update of documents add entry to changes containing REMOTE_USER and date/time
#
# list 
# 	List all databases available
# 	
# meta/database
# 	Retrieve meta json
#
# bbox/database/layer/x1/y1/x2/y2
#
# dummy
# 	Service valid and empty js
#

get '/dummy' => sub {
	my $self = shift;
	$self->render( json => {} );
};

get '/list' => sub {
	my $self = shift;

	opendir(my $dh, $dbdir) || die "Can't opendir $dbdir $!";
	my @files = sort map { s/\.sqlite$//; $_; }
		grep { /.sqlite$/ && -f "$dbdir/$_" } readdir($dh);
	closedir $dh;

	my @metas = map { my $meta=db_meta_get(db_open($_)); $meta->{dbname}=$_; $meta; } @files;

	$self->res->headers->header('Access-Control-Allow-Origin' => '*');
	$self->render( json => \@metas );
};


sub db_open {
	my ($dbname) = @_;

	$dbname =~ s/[\.\/]+//g;

	# Need to stat the file - else fail

	my $dbconfig=sprintf('dbi:SQLite:dbname=%s/%s.sqlite', $dbdir, $dbname);
	my $dbh = DBI->connect($dbconfig, "", "", { sqlite_unicode => 1 });

	$dbh->sqlite_load_extension("mod_spatialite");

	return $dbh;
}

# Read the meta table and unflatten to a datastructure
sub db_meta_get {
	my ($dbh) = @_;

	my $sql=$dbh->prepare("select key,value from meta");
	$sql->execute();
	my $rows=$sql->fetchall_arrayref();

	my $meta;
	foreach my $row ( @{$rows} ) {
		$meta->{$row->[0]}=$row->[1];
	}

	return unflatten($meta);
}

get '/meta/:dbname' => sub {
	my $self = shift;
	my $dbh=db_open($self->param("dbname"));

	$self->res->headers->header('Access-Control-Allow-Origin' => '*');
	$self->render( json => db_meta_get($dbh));
};

sub row_to_geojson_feature {
	my ($layer, $row) = @_;

	my $geojson=from_json($row->{geojson});

	my $new={ "geometry" => $geojson, "type" => "Feature" };

	# Copy all columns except the geometry to the feature properties
	my @keys=grep { !/geometry/ } keys %{$row};

	foreach my $column ( @keys ) {
		$new->{properties}{$column}=$row->{$column};
	}

	return $new;
}

get '/bbox/:dbname/:layer/#x1/#y1/#x2/#y2' => sub {
	my $self = shift;
	my $dbh=db_open($self->param("dbname"));
	my $meta=db_meta_get($dbh);

	my $layername=$self->param("layer");

	if (!defined($meta->{layer}{$layername})) {
		$self->render(status => 404, text => "Layer not found");
		return;
	}

	my $layer=$meta->{layer}{$layername};
	my $columns=join(",", @{$layer->{columns}});

	my $sqlstring=sprintf(
			"select	AsGeoJSON(%s) geojson,
				MbrMinX(Buffer(%s, 0.0005)) xmin,
				MbrMaxX(Buffer(%s, 0.0005)) xmax,
				MbrMinY(Buffer(%s, 0.0005)) ymin,
				MbrMaxY(Buffer(%s, 0.0005)) ymax,
				%s
			from	%s
			where	ST_Intersects(%s, BuildMbr(%s,%s,%s,%s,4326))
			limit	2000",
			$layer->{geometrycolumn}, $layer->{geometrycolumn}, $layer->{geometrycolumn},
			$layer->{geometrycolumn}, $layer->{geometrycolumn}, $columns, $layername, $layer->{geometrycolumn},
 			sprintf("%f", $self->param("x1")),
			sprintf("%f", $self->param("y1")),
			sprintf("%f", $self->param("x2")),
			sprintf("%f", $self->param("y2"))
		);

	my $sql=$dbh->prepare($sqlstring) || die $DBI::errstr;

	#print STDERR $sqlstring . "\n";

	# BuildMbr 	BuildMbr( x1 Double precision , y1 Double precision ,
	#            x2 Double precision , y2 Double precision [ , SRID Integer] ) : Geometry 	
	#
	#  base 	[x1 y1] and [x2 y2] are assumed to be Points identifying a line segment;
	#  then a Geometry will be returned representing the MBR for this line segment
	#

	$sql->execute();

	my @res;
	while(my $row=$sql->fetchrow_hashref()) {
		push @res, row_to_geojson_feature($layer, $row);
	}

	$self->res->headers->header('Access-Control-Allow-Origin' => '*');
	$self->render( json => { type => "FeatureCollection", features => \@res, properties => { meta => $meta } });
};

app->start;

